---
title: "Untitled"
output: html_document
date: "2023-02-15"
editor_options: 
  chunk_output_type: console
---
This code was used for the simulation study assessing the performance of RNAseqCovarImpute, complete case, and single imputation analysis on completely synthetic covariate and RNA-seq count data. These simulations were run at sample sizes 100, 200, and 500. MAR and MCAR missingness mechanisms were explored at 5-55% missing data levels. 
```{r}
library(tidyverse)
library(mice)
library(edgeR)
library(openxlsx)
library(BiocStyle)
library(xtable)
library(tximport)
library(Glimma)
library(org.Hs.eg.db)
library(doParallel)
library(foreach)
library(RNAseqCovarImpute)
library(doRNG)
library(seqgendiff)
library(simstudy)
library(missForest)
set.seed(2023)
sample_size <- 500
# Generate 5 random binary variables that are correlated with each other
R <- genCorMat(5, cors = c(.1, .1, .1, .1, 0, 0, 0, 0, 0, 0))
data <- genCorGen(sample_size, nvars = 5, params1 = c(.5, .5, .5, .5, .5), dist = "binary", corMatrix = R, corstr = "cs", wide = TRUE)
data <- data %>% dplyr::select(-id)
```

The code commented out below makes synthetic RNA-seq count data using the seqgendiff package.
```{r}
# alldg_3_vars is the name of the real RNA-seq data that was modified to
# create the mat500.RDS, mat200.RDS, and mat100.RDS synthetic count datasets

# mat <- readRDS("./alldg_3_vars.RDS")
# mode(mat$counts)<- "integer"
# # Sample down genes to make simulations faster
#
# mat = mat[sample(1:nrow(mat),2000), ]
#
# Sample down individuals to chosen sample size
# mat = mat[,sample(1:ncol(mat),sample_size), ]
# nrow(mat)
# ncol(mat)
#
# # Name the sample columns
# annot = tibble(number = 1:sample_size, name1 = "Sample") %>% mutate(sample = str_c(name1,number)) %>% dplyr::select(sample)
# colnames(mat) <- annot$sample
#
# data_pred = data
#
# # Generate random differential expression coefficients
# designmat = model.matrix(~0 + V1 + V2 + V3 + V4 + V5, data_pred)
#
# new_coefs <- matrix(stats::rgamma(ncol(designmat) * nrow(mat), shape = 1, rate = 3),
#                   ncol = ncol(designmat),
#                   nrow = nrow(mat))
#
# plot(density(new_coefs))
#
# Set desired proportion of genes to null
# nullvec <- sample(x = c(TRUE, FALSE),
#                   size = nrow(new_coefs),
#                   replace = TRUE,
#                   prob = c(0.825, 0.175))
# new_coefs[nullvec, 1] <- 0
#
# # Use binomial thinning method to modify synthetic count matrix to closely match to our desired random coefficients above
#
# thout <- thin_diff(mat          = mat$counts,
#                    design_fixed = designmat,
#                    coef_fixed   = new_coefs)
#
# # Replace the count matrix in our dge list with the counts modified above
# alldg_ampute = mat
# alldg_ampute$counts <- thout$mat
# rownames(alldg_ampute) <- rownames(mat)
# colnames(alldg_ampute) <- colnames(mat)
# saveRDS(mat, "mat500.RDS")
```


Simulate missingness and check performance of RNAseqCovarImpute, complete case, and single imputation methods
To run at other sample sizes, change "sample_size = 500" above to 100 or 200. Then read in corresponding 
synthetic count matrix below (e.g., alldg_ampute = readRDS("mat200.RDS")).
```{r}
alldg_ampute <- readRDS("mat500.RDS")
# alldg_ampute = readRDS("mat200.RDS")
# alldg_ampute = readRDS("mat100.RDS")
# New design that has an intercept
new_design <- model.matrix(~ V1 + V2 + V3 + V4 + V5, data)
# new_design = model.matrix(~V1 + V2 + V3, data)

# Use limma-voom to get what we define as the true coefficients and true significantly differentially expressed genes
vout <- limma::voom(alldg_ampute, design = new_design)
lout <- limma::lmFit(vout)
coefhat <- coef(lout)[, -1, drop = FALSE]
eout <- eBayes(lout)
top.table1 <- topTable(eout, coef = "V1", sort.by = "P", n = Inf) %>%
    mutate(significant = ifelse(adj.P.Val < 0.05, "Yes", "No"))

# Put true results that we need together
truth_res2 <- tibble(
    ENSEMBL = rownames(top.table1),
    coef_verify = top.table1$logFC,
    significant = top.table1$significant
) %>%
    mutate(null = significant == "No")

# Formula for design matrix
adj_formula <- "~V1 + V2 + V3 + V4 + V5"

# Missingness pattern for simulations below
# Pattern to allow one row to have multiple missing variables. First get all combos of 0 or 1 for the 2 variables
pattern_vars <- expand.grid(0:1, 0:1, 0:1, 0:1)
# then add back the predictor of interest, which is never amputed, so the first col =1 the whole way down
pattern2 <- matrix(1, nrow = nrow(pattern_vars), ncol = 1)
pattern1 <- cbind(pattern2, pattern_vars)
# remove last row which is all 1s (all 1s means no missingness induced)
pattern1 <- pattern1[1:15, ]

simulation2 <- function(data, mat, voom_formula, predictor, miss_mech, prop_miss, pattern) {
    RNGkind("L'Ecuyer-CMRG")
    mcoptions <- list(mc.set.seed = TRUE)
    myCluster <- makeCluster(5, # number of cores to use
        type = "PSOCK"
    ) # type of cluster
    registerDoParallel(myCluster)

    all_coef_se <- foreach(i = 1:10, .options.multicore = mcoptions) %dorng% {
        library(tidyverse)
        library(mice)
        library(edgeR)
        library(openxlsx)
        library(BiocStyle)
        library(xtable)
        library(tximport)
        library(Glimma)
        library(org.Hs.eg.db)
        library(doParallel)
        library(foreach)
        library(RNAseqCovarImpute)
        library(missForest)
        # induce missingness in the data
        result <- ampute(data = data, prop = prop_miss, mech = miss_mech, patterns = pattern)
        # pull out the data with missingness
        ampute_i <- result$amp
        # rename as factors, ampute turns them into continuous
        ampute_i <- ampute_i %>% mutate(
            V1 = as.factor(V1),
            V2 = as.factor(V2),
            V3 = as.factor(V3),
            V4 = as.factor(V4),
            V5 = as.factor(V5)
        )
        # Run first part of RNAseqCovarImpute analysis
        # get gen bin intervals
        intervals <- get_gene_bin_intervals(mat, ampute_i)
        # make imputed datasets for each gene bin
        imputed_data_list <- impute_by_gene_bin(data = ampute_i, intervals = intervals, DGE = mat, n = 10)
        # run limma-voom on all imputed datasets
        coef_se <- limmavoom_imputed_data_list(gene_intervals = intervals, DGE = mat, imputed_data_list = imputed_data_list, n = 10, voom_formula = voom_formula, predictor = "V11")

        # run single imputation with random forest
        data_si <- ampute_i
        data_si <- missForest(data_si)
        data_si <- data_si$ximp
        # output these datasets for comparison below
        output2 <- list(coef_se, imputed_data_list, data_si)
    }


    # pool results for RNAseqCovarImpute
    rubins_res <- foreach(i = 1:10) %do% {
        all_coef_se_i <- all_coef_se[[i]][[1]]
        combine_rubins(DGE = mat, model_results = all_coef_se_i, voom_formula = voom_formula)
    }

    # comapre RNAseqCovarImpute to the true model
    truth_vs_impute <- foreach(i = 1:as.numeric(length(rubins_res))) %do% {
        rubins_res_i <- rubins_res[[i]]
        is_null_gene <- truth_res2$significant == "No"
        # add together with true model. join by gene
        both_models <- truth_res2 %>%
            dplyr::select(-significant) %>%
            left_join(rubins_res_i) %>%
            dplyr::rename(p_adj = combined_p_adj_bayes) %>%
            mutate(significant = ifelse(p_adj < 0.05, "Yes", "No"))

        # compare to limma voom model on full data
        true_number <- both_models %>%
            dplyr::filter(null == FALSE) %>%
            nrow() %>%
            as.numeric()
        true_identified <- both_models %>%
            dplyr::filter(null == FALSE) %>%
            dplyr::filter(significant == "Yes") %>%
            nrow() %>%
            as.numeric()
        false_pos <- both_models %>%
            dplyr::filter(significant == "Yes") %>%
            dplyr::filter(null == TRUE) %>%
            nrow() %>%
            as.numeric()
        total_pos <- both_models %>%
            dplyr::filter(significant == "Yes") %>%
            nrow() %>%
            as.numeric()

        error_summary <- tibble(
            prop_true_identifed = true_identified / true_number,
            false_pos_ratio = false_pos / total_pos
        ) %>%
            mutate(
                Method = "RNAseqCovarImpute",
                Predictor = colnames(all_coef_se[[1]][[3]])[1]
            )

        coefs <- both_models %>% dplyr::select(ENSEMBL, coef_combined, coef_verify, null, significant)

        output <- list(
            error = error_summary,
            coefs = coefs
        )
    }

    savename1 <- paste0("truth_vs_impute_syn_", miss_mech, "_", predictor, "_", as.character(prop_miss), "_synthetic_data_10_cor_2000_genes_500")

    saveRDS(truth_vs_impute, savename1)

    # comapre complete case and single imputation to the true model
    truth_vs_cc <- foreach(i = 1:as.numeric(length(rubins_res))) %do% {
        # Get the ith amputation and make a complete case dataset by droppping NAs
        ampute_i <- complete(all_coef_se[[i]][[2]][[1]], 0) %>%
            dplyr::select(-starts_with("ENS")) %>%
            mutate(pathways_id = colnames(mat)) %>%
            drop_na()
        # Run limma-voom
        alldg_i <- mat[, ampute_i$pathways_id]
        design1 <- model.matrix(as.formula(voom_formula), ampute_i)
        fit1 <- eBayes(voomLmFit(alldg_i, design1))
        top.table1 <- topTable(fit1, coef = "V11", sort.by = "P", n = Inf)

        both_models <- truth_res2 %>%
            dplyr::select(-significant) %>%
            left_join(top.table1) %>%
            mutate(significant = ifelse(adj.P.Val < 0.05, "Yes", "No"))

        # compare to limma voom model on full data
        true_number <- both_models %>%
            dplyr::filter(null == FALSE) %>%
            nrow() %>%
            as.numeric()
        true_identified <- both_models %>%
            dplyr::filter(null == FALSE) %>%
            dplyr::filter(significant == "Yes") %>%
            nrow() %>%
            as.numeric()
        false_pos <- both_models %>%
            dplyr::filter(significant == "Yes") %>%
            dplyr::filter(null == TRUE) %>%
            nrow() %>%
            as.numeric()
        total_pos <- both_models %>%
            dplyr::filter(significant == "Yes") %>%
            nrow() %>%
            as.numeric()

        error_summary <- tibble(
            prop_true_identifed = true_identified / true_number,
            false_pos_ratio = false_pos / total_pos
        ) %>%
            mutate(
                Method = "Complete case",
                Predictor = colnames(all_coef_se[[1]][[3]])[1]
            )

        # Get single imputation model
        data_si <- all_coef_se[[i]][[3]] %>%
            mutate(pathways_id = colnames(mat))
        # Run limma-voom
        alldg_si <- mat[, data_si$pathways_id]
        design_si <- model.matrix(as.formula(voom_formula), data_si)
        fit_si <- eBayes(voomLmFit(alldg_si, design_si))
        top.table_si <- topTable(fit_si, coef = "V11", sort.by = "P", n = Inf)

        both_models_si <- truth_res2 %>%
            dplyr::select(-significant) %>%
            left_join(top.table_si) %>%
            mutate(significant = ifelse(adj.P.Val < 0.05, "Yes", "No"))

        # compare to limma voom model on full data
        true_number <- both_models_si %>%
            dplyr::filter(null == FALSE) %>%
            nrow() %>%
            as.numeric()
        true_identified <- both_models_si %>%
            dplyr::filter(null == FALSE) %>%
            dplyr::filter(significant == "Yes") %>%
            nrow() %>%
            as.numeric()
        false_pos <- both_models_si %>%
            dplyr::filter(significant == "Yes") %>%
            dplyr::filter(null == TRUE) %>%
            nrow() %>%
            as.numeric()
        total_pos <- both_models_si %>%
            dplyr::filter(significant == "Yes") %>%
            nrow() %>%
            as.numeric()

        error_summary_si <- tibble(
            prop_true_identifed = true_identified / true_number,
            false_pos_ratio = false_pos / total_pos
        ) %>%
            mutate(
                Method = "Single imputation",
                Predictor = colnames(all_coef_se[[1]][[3]])[1]
            )

        coefs_si <- both_models_si %>%
            dplyr::select(ENSEMBL, logFC, coef_verify) %>%
            dplyr::rename(
                logFC_si = logFC,
                coef_verify_si = coef_verify
            )
        coefs <- both_models %>%
            dplyr::select(ENSEMBL, logFC, coef_verify, null, significant) %>%
            left_join(coefs_si)

        output <- list(
            error = error_summary,
            error_si = error_summary_si,
            coefs = coefs
        )
    }


    savename2 <- paste0("truth_vs_cc_syn_", miss_mech, "_", predictor, "_", as.character(prop_miss), "_synthetic_data_10_cor_2000_genes_500")
    saveRDS(truth_vs_cc, savename2)
}
```

With the above function, we can easily modify the missingness mechanism and the proportion missing. 
```{r}
time1 <- Sys.time()
simulation2(data = data, mat = alldg_ampute, voom_formula = adj_formula, predictor = "V1", miss_mech = "MAR", prop_miss = 5, pattern = pattern1)
simulation2(data = data, mat = alldg_ampute, voom_formula = adj_formula, predictor = "V1", miss_mech = "MAR", prop_miss = 15, pattern = pattern1)
simulation2(data = data, mat = alldg_ampute, voom_formula = adj_formula, predictor = "V1", miss_mech = "MAR", prop_miss = 25, pattern = pattern1)
simulation2(data = data, mat = alldg_ampute, voom_formula = adj_formula, predictor = "V1", miss_mech = "MAR", prop_miss = 35, pattern = pattern1)
simulation2(data = data, mat = alldg_ampute, voom_formula = adj_formula, predictor = "V1", miss_mech = "MAR", prop_miss = 45, pattern = pattern1)
simulation2(data = data, mat = alldg_ampute, voom_formula = adj_formula, predictor = "V1", miss_mech = "MAR", prop_miss = 55, pattern = pattern1)
time2 <- Sys.time()
print(time2 - time1)

time1 <- Sys.time()
simulation2(data = data, mat = alldg_ampute, voom_formula = adj_formula, predictor = "V1", miss_mech = "MCAR", prop_miss = 5, pattern = pattern1)
simulation2(data = data, mat = alldg_ampute, voom_formula = adj_formula, predictor = "V1", miss_mech = "MCAR", prop_miss = 15, pattern = pattern1)
simulation2(data = data, mat = alldg_ampute, voom_formula = adj_formula, predictor = "V1", miss_mech = "MCAR", prop_miss = 25, pattern = pattern1)
simulation2(data = data, mat = alldg_ampute, voom_formula = adj_formula, predictor = "V1", miss_mech = "MCAR", prop_miss = 35, pattern = pattern1)
simulation2(data = data, mat = alldg_ampute, voom_formula = adj_formula, predictor = "V1", miss_mech = "MCAR", prop_miss = 45, pattern = pattern1)
simulation2(data = data, mat = alldg_ampute, voom_formula = adj_formula, predictor = "V1", miss_mech = "MCAR", prop_miss = 55, pattern = pattern1)
time2 <- Sys.time()
print(time2 - time1)
```

